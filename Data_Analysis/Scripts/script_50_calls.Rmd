---
  title: "Rscript - 50 calls, Titi alarm calls"
author: "Narbona Sabat√© L. & Berthet M."
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script uses function for the cfp package, that needs to be installed with command 
library(devtools)
devtools::install_github("gobbios/cfp")

Install and load the following packages:

```{r, message=FALSE, warning=FALSE}
library(cfp)
library(RColorBrewer)
library(tidyverse)
```

#1. What do alarm sequences encode?
The aim of this script is i) to create a data file with, for each sequence, the type of predator, the location, the distance between the caller and the predator, and the 15 metrics and ii) to infer what information is encoded by each metric with model selection


```{r}

# read data from the excel file provided with the script, "predator presentations" dataset. 
#It contains 50 sequences of 10 calls each.
xdata <- read.delim('Data/dataset_pred_prez_50-calls_chgd.txt')
#xdata$Seq1 <- as.factor(xdata$Seq1)

#Calls of each sequences are given in column, transform them into character strings
SeqCalls <- sapply(unique(xdata$Seq1), function(X) 
  paste0(xdata$Type_call[xdata$Seq1 == X], collapse=""))


#combine all relevant info of each sequence (Code of the sequence, Group of the caller, 
#type and location of the predator, distance predator-caller and call sequence) into one dataset 
#that will be used as a template and be filled with metric values
xdata2 <- data.frame(seqID = unique(xdata$Seq1), group=as.character(xdata$Group
[which(xdata$Nb_call==1)]), ind=as.character(xdata$Ind
[which(xdata$Nb_call==1)]), preda = as.character
(xdata$Cat_preda[which(xdata$Nb_call==1)]), 
                     loca = as.character(xdata$Location[which(xdata$Nb_call==1)]), 
                     dis = xdata$Distance[which(xdata$Nb_call==1)], seqcall = SeqCalls, first_call = substr(SeqCalls, start = 1, stop = 1))
                        
```


We begin to fill up the table with the metrics

## 1.a Metrics extraction
###Slope of elements, Bayesian proportion of A-calls, mean and CV of call interval

```{r}
#Function callinterval to extract the call intervals from the sequences. 
#Output can be the mean call interval(outp="mean") 
#or the coefficient of variation of the call interval (outp="CV").
callintervals <- function(xdata, seqID, seqcol, starttime, endtime, outp="mean") { 
  temp <- xdata[xdata[, seqcol] == seqID, c(starttime, endtime)]
  res <- temp[2:nrow(temp), 1] - temp[1:(nrow(temp)-1) , 2]
  CV <- function(x) sd(x)/mean(x)
  if(outp == "mean") res <- mean(res)
  if(outp == "CV") res <- CV(res)
  return(res)
}

#Function Bayesian probabilities
bayesian_mean <- function(count_of_i, alpha_i, nb_of_events, k, multipl=1) {
  mean_i <- sum(count_of_i*multipl, alpha_i)/sum(nb_of_events, k*alpha_i) #"multipl" just in case 
                                                                          #the value was already a proportion
  return(mean_i)
}

#Fill the dataset with the slope of elements, the proportion of A-calls, 
#the mean call interval and the coefficient of variation of the call interval.

for(i in 1:nrow(xdata2)) {
  xdata2$elementA[i] <- elementslope(as.character(xdata2$seqcall[i]), type="linear", target="A")
  xdata2$elementB[i] <- elementslope(as.character(xdata2$seqcall[i]), type="linear", target="B")
  xdata2$elementD[i] <- elementslope(as.character(xdata2$seqcall[i]), type="linear", target="D")
  xdata2$elementE[i] <- elementslope(as.character(xdata2$seqcall[i]), type="linear", target="E")    
  xdata2$propA[i] <- elementprop(as.character(xdata2$seqcall[i]), target = "A")
  xdata2$propB[i] <- elementprop(as.character(xdata2$seqcall[i]), target = "B")
  xdata2$propC[i] <- elementprop(as.character(xdata2$seqcall[i]), target = "C")
  xdata2$propD[i] <- elementprop(as.character(xdata2$seqcall[i]), target = "D")
  xdata2$propE[i] <- elementprop(as.character(xdata2$seqcall[i]), target = "E")
  xdata2$meaninterval[i] <- callintervals(xdata, seqID=as.character(xdata2$seqID[i]), 
                    seqcol="Seq1", starttime="Begin_call", endtime="End_call", outp="mean")
  xdata2$CVinterval[i] <- callintervals(xdata, seqID=as.character(xdata2$seqID[i]), 
                    seqcol="Seq1", starttime="Begin_call", endtime="End_call", outp="CV")
}

#Bayesian proportion of A, B, C, BS and AS-calls (i.e. we add 1 to the number of calls in the sequence and divide 
#by 15 (5 possibilities of calls (A,B,C,BS, and AS) + 10 calls in the sequence))

xdata2$propA <- sapply(xdata2$propA, bayesian_mean, 1/5, 50, 5, 50)
xdata2$propB <- sapply(xdata2$propB, bayesian_mean, 1/5, 50, 5, 50)
xdata2$propC <- sapply(xdata2$propC, bayesian_mean, 1/5, 50, 5, 50)
xdata2$propD <- sapply(xdata2$propD, bayesian_mean, 1/5, 50, 5, 50)
xdata2$propE <- sapply(xdata2$propE, bayesian_mean, 1/5, 50, 5, 50)

```

### Computation of ngrams

```{r}
peak <- 0.3183865 #Computed in script_graph
seqID <- unique(xdata$Seq1) 
nb_calls <- head(unique(xdata$Nb_call), -1)
target_calls <- c("A", "B", "D", "E")

#Creation of the needed columns of data (from bi to pentagrams):
for (call1 in target_calls) {
  for (call2 in target_calls){
      bigram <- paste("bigram_", call1, call2, sep="")
      xdata2[,bigram] <- 0
    for (call3 in target_calls){
      trigram <- paste("trigram_", call1, call2, call3, sep="")
      xdata2[,trigram] <- 0
      for (call4 in target_calls){
        tetragram <- paste("tetragram_", call1, call2, call3, call4, sep="")
        xdata2[,tetragram] <- 0
        for (call5 in target_calls){
          pentagram <- paste("pentagram_", call1, call2, call3, call4, call5, sep="")
          xdata2[,pentagram] <- 0
        }
      }
    }
  }
  rm(call1, call2, call3, call4, call5)
}

prefixes <- c("bi", "tri", "tetra", "penta")

for (id in seqID) {
  data1 <- xdata[xdata$Seq1 == as.character(id),]
  data1 <- data1[1:10,]
  for (i in nb_calls){
    for (j in 1:4){
       end1 <- data1[data1$Nb_call == i + j - 1, "End_call"]
       begin1 <- data1[data1$Nb_call == i + j, "Begin_call"]
       distance1 <- begin1 - end1
       {if(distance1 < 0 || identical(distance1, numeric(0))){
         next
       }
        else{
          {if(distance1 >= peak){
            gram <- paste(prefixes[[j]], "gram_", sep="")
            print(gram)
            y <- i+j
            for (m in c(i:y)){
              type <- data1[data1$Nb_call == m, "Type_call"]
              gram <- paste(gram, type, sep="")
              print(gram)
            }
            {if (!(gram %in% names(xdata2))) {
              next
            }
            else{
                xdata2[xdata2$seqID == as.character(id),gram] <- sum(xdata2[xdata2$seqID == as.character(id),gram], 1)
            }
            }
          }
           else{
          next}
           
          }
        }
      }
    }
  }
  rm(id,i, j, m, data1,end1,begin1,distance1,gram,type,y)
}



```

### Slope of ngrams and Bayesian proportion of ngrams

```{r}
#take the index of columns representing the number of ngrams, etc.
id_bigram_columns <- grep("bigram_", names(xdata2)) 
id_trigram_columns <- grep("trigram_", names(xdata2))
id_tetragram_columns <- grep("tetragram_", names(xdata2))
id_pentagram_columns <- grep("pentagram_", names(xdata2))

#Create the columns in the dataset
xdata2$slope_bigram <- NA
xdata2$slope_trigram <- NA
xdata2$slope_tetragram <- NA
xdata2$slope_pentagram <- NA

#For each sequence, fill the slopes & calculate each Bayesian proportion of the ngrams
for(row in 1:nrow(xdata2)) {
  bi_temp <- data.frame(gram=character(), cnt=numeric(), stringsAsFactors=FALSE)
  tri_temp <- data.frame(gram=character(), cnt=numeric(), stringsAsFactors=FALSE)
  tetra_temp <- data.frame(gram=character(), cnt=numeric(), stringsAsFactors=FALSE)
  penta_temp <- data.frame(gram=character(), cnt=numeric(), stringsAsFactors=FALSE)
  
  total_bigrams <- sum(xdata2[row, id_bigram_columns])
  total_trigrams <- sum(xdata2[row, id_bigram_columns])
  total_tetragrams <- sum(xdata2[row, id_bigram_columns])
  total_pentagrams <- sum(xdata2[row, id_bigram_columns])
  
  alpha_bi <- 1/length(id_bigram_columns)
  alpha_tri <- 1/length(id_trigram_columns)
  alpha_tetra <- 1/length(id_tetragram_columns)
  alpha_penta <- 1/length(id_pentagram_columns)

  for (id in id_bigram_columns){
    bi_temp[nrow(bi_temp) + 1,] = c(names(xdata2[id]), xdata2[row,id])
    rownames(bi_temp) <- as.character(bi_temp$gram)
    
    xdata2[row, id] <- bayesian_mean(xdata2[row, id],alpha_bi, total_bigrams, length(id_bigram_columns))
  }
  for (id in id_trigram_columns){
    tri_temp[nrow(tri_temp) + 1,] = c(names(xdata2[id]), xdata2[row,id])
    rownames(tri_temp) <- as.character(tri_temp$gram)
    
    xdata2[row, id] <- bayesian_mean(xdata2[row, id],alpha_tri, total_trigrams, length(id_trigram_columns))
  }
  for (id in id_tetragram_columns){
    tetra_temp[nrow(tetra_temp) + 1,] = c(names(xdata2[id]), xdata2[row,id])
    rownames(tetra_temp) <- as.character(tetra_temp$gram)

    xdata2[row, id] <- bayesian_mean(xdata2[row, id],alpha_tetra, total_tetragrams, length(id_tetragram_columns))
  }
  for (id in id_pentagram_columns){
    penta_temp[nrow(penta_temp) + 1,] = c(names(xdata2[id]), xdata2[row,id])
    rownames(penta_temp) <- as.character(penta_temp$gram)
  
    xdata2[row, id] <- bayesian_mean(xdata2[row, id],alpha_penta, total_pentagrams, length(id_pentagram_columns))
    
    }
  
  bi_temp <- sort(as.numeric(bi_temp$cnt), decreasing = T)
  tri_temp <- sort(as.numeric(tri_temp$cnt), decreasing = T)
  tetra_temp <- sort(as.numeric(tetra_temp$cnt), decreasing = T)
  penta_temp <- sort(as.numeric(penta_temp$cnt), decreasing = T)
  
  xdata2$slope_bigram[row] <- lm(bi_temp ~ c(1:length(bi_temp)))$coefficients[2]
  xdata2$slope_trigram[row] <- lm(tri_temp ~ c(1:length(tri_temp)))$coefficients[2]
  xdata2$slope_tetragram[row] <- lm(tetra_temp ~ c(1:length(tetra_temp)))$coefficients[2]
  xdata2$slope_pentagram[row] <- lm(penta_temp ~ c(1:length(penta_temp)))$coefficients[2]

}

#Check Bayesian proportions
for(row in 1:nrow(xdata2)) {
  print(sum(xdata2[row, id_bigram_columns]))
  print(sum(xdata2[row, id_trigram_columns]))
  print(sum(xdata2[row, id_tetragram_columns]))
  print(sum(xdata2[row, id_pentagram_columns]))
}

```

### Shannon entropy

Regression coefficient from the zero, first and second order Shannon entropy

```{r}
#Create the empty column
xdata2$entroSlope <- NA

#Extract the Zero, first and second order Shannon entropy 
#and extract the regression coefficient from the three values
for (i in 1:nrow(xdata2)) {
  # collect the three entropy values...
  temp <- entropy(as.character(xdata2$seqcall[i]), n=0)
  temp <- c(temp, entropy(as.character(xdata2$seqcall[i]), n=1))
  temp <- c(temp, entropy(as.character(xdata2$seqcall[i]), n=2))
  # and run regression
  xdata2$entroSlope[i] <- lm(temp ~ c(1:3))$coefficients[2]
  rm(temp)
}
```

### Bayesian probability of transition

```{r}
#Create a matrix of transition: first column= the first call; first row= the second call
strumat <- matrix(1, ncol=5, nrow=6)
colnames(strumat) <- c("A", "B", "C", "D", "E")
rownames(strumat) <- c("start", "A", "B", "C", "D", "E")
strumat[1,3] <- 0
strumat[1,4] <- 0
strumat[1,5] <- 0 #Define which transitions is not possible, 
#here it is not possible to begin the sequence with a C-call, BS-call (E) and a AS-call (D) since 
#the first one is not an alarm call and the other ones are 

#Define what are the important transitions
targets <- c("start-A", "start-B", "A-A", "A-B", "A-C", "A-D", "A-E", "B-A", "B-B", "B-C", "B-D", "B-E", "D-A", "D-B", "D-C", "D-D", "D-E", "E-A", "E-B", "E-C", "E-D", "E-E")
# Integrate a column for each transition probability in the big dataset
xdata2 <- cbind(xdata2,  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA)
colnames(xdata2)[(ncol(xdata2)-21) : ncol(xdata2)] <- targets

#extract all the Bayesian transition probabilities that we selected before
for(i in 1:nrow(xdata2)) {
  temp <- transitions(as.character(xdata2$seqcall[i]), strucmat=strumat,
                      xstart=T, xstop=F, out="bayes")
  xdata2[i, targets] <- sapply(targets, function(X) 
    temp[strsplit(X, "-")[[1]][1], strsplit(X, "-")[[1]][2]])
  rm(temp)
}
#Give names of the transitions to the columns
targets <- c("tpSA", "tpSB", "tpAA", "tpAB", "tpAC", "tpAD", "tpAE", "tpBA", "tpBB", "tpBC", "tpBD", "tpBE", "tpDA", "tpDB", "tpDC", "tpDD", "tpDE", "tpEA", "tpEB", "tpEC", "tpED", "tpEE")
colnames(xdata2)[(ncol(xdata2)-21) : ncol(xdata2)] <- targets
rm(targets)
```

### Add social informations

```{r}

# read data from the excel file provided with the script, "additional_info". 
#It contains more info for each sequence
social_data <- read.delim('Data/dataset_pred_prez_50-calls_add-info.txt')

#Add it to xdata2
final_dataset_50 <- left_join(xdata2, social_data)

```
### Create a dataset from the data

```{r}
write.table(final_dataset_50, file = "Data/50_calls_metrics.txt", sep = "\t",
            row.names = TRUE)
```